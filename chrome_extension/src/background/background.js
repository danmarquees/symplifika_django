// Background Script para Symplifika Chrome Extension (Vue.js)
// Gerencia autentica√ß√£o, sincroniza√ß√£o e comunica√ß√£o com API

const API_BASE_URL = "http://127.0.0.1:8000";

// Estado da extens√£o
let extensionState = {
  isAuthenticated: false,
  user: null,
  token: null,
  shortcuts: [],
  lastSync: null,
};

// Restaurar estado do storage
async function restoreState() {
  try {
    const result = await chrome.storage.local.get([
      "token",
      "user",
      "shortcuts",
      "lastSync",
    ]);

    if (result.token) {
      extensionState.token = result.token;
      extensionState.isAuthenticated = true;
    }

    if (result.user) {
      extensionState.user = result.user;
    }

    if (result.shortcuts) {
      extensionState.shortcuts = result.shortcuts;
      console.log(
        `üì¶ ${result.shortcuts.length} atalhos restaurados do storage`,
      );
    }

    if (result.lastSync) {
      extensionState.lastSync = result.lastSync;
    }

    console.log("üì¶ Estado restaurado:", {
      authenticated: extensionState.isAuthenticated,
      user: extensionState.user?.username,
      shortcuts: extensionState.shortcuts?.length || 0,
    });
  } catch (error) {
    console.error("‚ùå Erro ao restaurar estado:", error);
  }
}

// Salvar estado no storage
async function saveState() {
  try {
    await chrome.storage.local.set({
      token: extensionState.token,
      user: extensionState.user,
      shortcuts: extensionState.shortcuts,
      lastSync: extensionState.lastSync,
    });
  } catch (error) {
    console.error("‚ùå Erro ao salvar estado:", error);
  }
}

// Tentativa de login autom√°tico via sess√£o Django
async function tryAutoLogin() {
  try {
    console.log("üîÑ Tentando login autom√°tico via sess√£o Django...");

    const response = await fetch(
      `${API_BASE_URL}/users/api/auth/check-session/`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Origin: chrome.runtime.getURL(""),
        },
        credentials: "include", // Incluir cookies de sess√£o
      },
    );

    console.log("üì° Status da resposta auto-login:", response.status);

    if (response.ok) {
      const data = await response.json();
      console.log("üìÑ Dados da resposta auto-login:", data);

      if (data.authenticated && data.access) {
        // Login autom√°tico bem-sucedido
        extensionState.token = data.access;
        extensionState.user = data.user;
        extensionState.isAuthenticated = true;

        // Salvar no storage
        await saveState();

        // Sincronizar atalhos
        await syncShortcuts();

        console.log(
          "‚úÖ Login autom√°tico realizado com sucesso:",
          extensionState.user.username,
        );

        return {
          success: true,
          user: extensionState.user,
          token: extensionState.token,
          message: "Login autom√°tico via sess√£o Django",
        };
      }
    }

    console.log("‚ÑπÔ∏è Usu√°rio n√£o est√° logado na aplica√ß√£o principal");
    return {
      success: false,
      error: "Usu√°rio n√£o est√° logado na aplica√ß√£o principal",
    };
  } catch (error) {
    console.error("‚ùå Erro no login autom√°tico:", error);
    return { success: false, error: "Erro de conex√£o no login autom√°tico" };
  }
}

// Listener para mensagens do popup e content script
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  // Verificar se a extens√£o ainda est√° ativa
  if (!chrome.runtime?.id) {
    console.warn(
      "‚ö†Ô∏è Extens√£o foi invalidada durante processamento de mensagem",
    );
    sendResponse({ success: false, error: "Extens√£o invalidada" });
    return false;
  }

  console.log("üì® Mensagem recebida:", request.type);

  // Processar de forma ass√≠ncrona
  (async () => {
    try {
      let response;

      switch (request.type) {
        case "LOGIN":
          response = await handleLogin(request.payload);
          break;

        case "AUTO_LOGIN":
          response = await tryAutoLogin();
          break;

        case "LOGOUT":
          response = await handleLogout();
          break;

        case "SYNC_SHORTCUTS":
          response = await syncShortcuts();
          break;

        case "GET_SHORTCUTS":
          console.log(
            `üìã Retornando ${extensionState.shortcuts.length} atalhos para popup`,
          );
          response = {
            success: true,
            shortcuts: extensionState.shortcuts,
            lastSync: extensionState.lastSync,
          };
          break;

        case "EXPAND_TEXT":
          response = await handleTextExpansion(request.payload);
          break;

        case "USE_SHORTCUT":
          response = await markShortcutAsUsed(request.payload.shortcutId);
          break;

        case "PING":
          response = {
            success: true,
            status: "alive",
            authenticated: extensionState.isAuthenticated,
            shortcuts: extensionState.shortcuts.length,
            timestamp: Date.now(),
          };
          break;

        default:
          response = {
            success: false,
            error: "Comando desconhecido: " + request.type,
          };
      }

      // Verificar se ainda podemos enviar resposta
      if (chrome.runtime?.id && sendResponse) {
        try {
          sendResponse(response);
        } catch (sendError) {
          console.warn("‚ö†Ô∏è Erro ao enviar resposta:", sendError.message);
        }
      }
    } catch (error) {
      console.error("‚ùå Erro no background script:", error);
      if (chrome.runtime?.id && sendResponse) {
        try {
          sendResponse({ success: false, error: error.message });
        } catch (sendError) {
          console.warn(
            "‚ö†Ô∏è Erro ao enviar resposta de erro:",
            sendError.message,
          );
        }
      }
    }
  })();

  // Retornar true para manter o canal de comunica√ß√£o aberto
  return true;
});

// Fun√ß√£o de login
async function handleLogin(credentials) {
  try {
    console.log("üîê Tentando login para:", credentials.login);
    console.log("üåê URL da API:", `${API_BASE_URL}/api/token/`);

    const response = await fetch(`${API_BASE_URL}/api/token/`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Origin: chrome.runtime.getURL(""),
      },
      body: JSON.stringify({
        login: credentials.login,
        password: credentials.password,
      }),
    });

    console.log("üì° Status da resposta:", response.status, response.statusText);

    let data;
    try {
      data = await response.json();
      console.log("üìÑ Dados da resposta:", data);
    } catch (jsonError) {
      console.error("‚ùå Erro ao parsear JSON:", jsonError);
      const textData = await response.text();
      console.log("üìÑ Resposta como texto:", textData);
      return {
        success: false,
        error: `Erro no servidor (${response.status}): ${textData.substring(0, 100)}`,
      };
    }

    if (response.ok && data.access) {
      // Login bem-sucedido
      extensionState.token = data.access;
      extensionState.user = data.user;
      extensionState.isAuthenticated = true;

      // Salvar no storage
      await saveState();

      // Sincronizar atalhos
      await syncShortcuts();

      console.log(
        "‚úÖ Login realizado com sucesso:",
        extensionState.user.username,
      );

      return {
        success: true,
        user: extensionState.user,
        token: extensionState.token,
      };
    } else {
      console.error("‚ùå Erro no login:", data);
      return {
        success: false,
        error:
          data.error ||
          data.detail ||
          data.message ||
          `Erro HTTP ${response.status}`,
      };
    }
  } catch (error) {
    console.error("‚ùå Erro de conex√£o no login:", error);
    return {
      success: false,
      error: `Erro de conex√£o: ${error.message}. Verifique se o servidor Django est√° rodando em ${API_BASE_URL}`,
    };
  }
}

// Fun√ß√£o de logout
async function handleLogout() {
  try {
    // Limpar estado
    extensionState = {
      isAuthenticated: false,
      user: null,
      token: null,
      shortcuts: [],
      lastSync: null,
    };

    // Limpar storage
    await chrome.storage.local.clear();

    console.log("üëã Logout realizado");

    return { success: true };
  } catch (error) {
    console.error("‚ùå Erro no logout:", error);
    return { success: false, error: "Erro no logout" };
  }
}

// Sincronizar atalhos com a API
async function syncShortcuts() {
  if (!extensionState.isAuthenticated || !extensionState.token) {
    return { success: false, error: "N√£o autenticado" };
  }

  try {
    console.log("üîÑ Sincronizando atalhos...");

    const response = await fetch(`${API_BASE_URL}/shortcuts/api/shortcuts/`, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${extensionState.token}`,
        "Content-Type": "application/json",
      },
    });

    if (response.ok) {
      const data = await response.json();
      extensionState.shortcuts = data.results || data || [];
      extensionState.lastSync = new Date().toISOString();

      // Salvar no storage
      await saveState();

      console.log(
        `‚úÖ ${extensionState.shortcuts.length} atalhos sincronizados`,
      );

      return {
        success: true,
        shortcuts: extensionState.shortcuts,
        lastSync: extensionState.lastSync,
      };
    } else {
      console.error("‚ùå Erro na sincroniza√ß√£o:", response.status);
      return { success: false, error: "Erro na API" };
    }
  } catch (error) {
    console.error("‚ùå Erro de conex√£o na sincroniza√ß√£o:", error);
    return { success: false, error: "Erro de conex√£o" };
  }
}

// Marcar atalho como usado
async function markShortcutAsUsed(shortcutId) {
  if (!extensionState.isAuthenticated || !extensionState.token) {
    return { success: false, error: "N√£o autenticado" };
  }

  try {
    const response = await fetch(
      `${API_BASE_URL}/shortcuts/api/shortcuts/${shortcutId}/use/`,
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${extensionState.token}`,
          "Content-Type": "application/json",
        },
      },
    );

    if (response.ok) {
      console.log(`‚úÖ Atalho ${shortcutId} marcado como usado`);
      return { success: true };
    } else {
      console.error("‚ùå Erro ao marcar atalho como usado:", response.status);
      return { success: false, error: "Erro na API" };
    }
  } catch (error) {
    console.error("‚ùå Erro de conex√£o ao marcar uso:", error);
    return { success: false, error: "Erro de conex√£o" };
  }
}

// Expandir texto com atalho
async function handleTextExpansion(payload) {
  const { trigger } = payload;

  // Procurar atalho pelo trigger
  const shortcut = extensionState.shortcuts.find(
    (s) => s.trigger === trigger && s.is_active,
  );

  if (!shortcut) {
    return { success: false, error: "Atalho n√£o encontrado" };
  }

  try {
    // Processar template com vari√°veis
    let expandedText = shortcut.content;

    // Vari√°veis b√°sicas
    const now = new Date();
    const variables = {
      "user.name":
        extensionState.user?.first_name || extensionState.user?.username || "",
      "user.email": extensionState.user?.email || "",
      "date.today": now.toLocaleDateString("pt-BR"),
      "date.time": now.toLocaleTimeString("pt-BR"),
      "date.year": now.getFullYear().toString(),
      "date.month": (now.getMonth() + 1).toString().padStart(2, "0"),
      "date.day": now.getDate().toString().padStart(2, "0"),
    };

    // Substituir vari√°veis
    for (const [key, value] of Object.entries(variables)) {
      const regex = new RegExp(`{{\\s*${key}\\s*}}`, "g");
      expandedText = expandedText.replace(regex, value);
    }

    // Marcar como usado (opcional - n√£o bloquear se falhar)
    try {
      await fetch(
        `${API_BASE_URL}/shortcuts/api/shortcuts/${shortcut.id}/use/`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${extensionState.token}`,
            "Content-Type": "application/json",
          },
        },
      );
    } catch (error) {
      console.warn("‚ö†Ô∏è N√£o foi poss√≠vel marcar atalho como usado:", error);
    }

    console.log(
      "‚ú® Texto expandido:",
      trigger,
      "->",
      expandedText.substring(0, 50) + "...",
    );

    return {
      success: true,
      expandedText: expandedText,
      shortcut: shortcut,
    };
  } catch (error) {
    console.error("‚ùå Erro na expans√£o:", error);
    return { success: false, error: "Erro na expans√£o" };
  }
}

// Alarme de sincroniza√ß√£o autom√°tica
if (chrome.alarms) {
  chrome.alarms.onAlarm.addListener(async (alarm) => {
    if (alarm.name === "syncShortcuts" && extensionState.isAuthenticated) {
      console.log("‚è∞ Sincroniza√ß√£o autom√°tica iniciada");
      await syncShortcuts();
    }
  });
}

// Listeners para service worker (Manifest V3)
if (chrome.runtime.onStartup) {
  chrome.runtime.onStartup.addListener(async () => {
    console.log("üöÄ Service worker iniciado");
    await restoreState();

    if (extensionState.isAuthenticated) {
      console.log("üîÑ Sincroniza√ß√£o na inicializa√ß√£o");
      await syncShortcuts();
    }
  });
}

// Listener para quando a extens√£o √© instalada/atualizada
if (chrome.runtime.onInstalled) {
  chrome.runtime.onInstalled.addListener(async (details) => {
    console.log("üì¶ Extens√£o instalada/atualizada:", details.reason);
    await restoreState();

    if (extensionState.isAuthenticated) {
      console.log("üîÑ Sincroniza√ß√£o ap√≥s instala√ß√£o");
      await syncShortcuts();
    }
  });
}

// Inicializa√ß√£o imediata do background script
(async () => {
  await restoreState();

  if (extensionState.isAuthenticated) {
    console.log("üîÑ Sincroniza√ß√£o na inicializa√ß√£o do background");
    await syncShortcuts();
  } else {
    // Tentar login autom√°tico se n√£o estiver autenticado
    console.log("üîÑ Tentando login autom√°tico na inicializa√ß√£o...");
    const autoLoginResult = await tryAutoLogin();
    if (autoLoginResult.success) {
      console.log("‚úÖ Login autom√°tico bem-sucedido na inicializa√ß√£o");
    } else {
      console.log("‚ÑπÔ∏è Login autom√°tico n√£o dispon√≠vel:", autoLoginResult.error);
    }
  }
})();

console.log("üéØ Background script carregado - Symplifika v2.0.0");
